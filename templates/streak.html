<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Streak Map</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
    <style>
  :root { --gap: 14px; }
            /* your blue background */
  body {background: #59A6FF; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 18px; }
  header { display:flex; align-items:center; gap: 12px; margin-bottom: 12px; }
  .filter-btn { padding: 8px 12px; border:1px solid #ddd; border-radius:10px; text-decoration:none; color:#000; background:#f0f0f0; font-size: 15px; font-weight: bold; }
  .filter-btn:hover { background:#fff }
  .btn { padding: 8px 12px; border:1px solid #ddd; border-radius:10px; text-decoration:none; color:#111; background:#fafafa}
  .btn:hover { background:#fff }
  .grid { display:grid; grid-template-columns: 1fr; gap: var(--gap); }
  .card { border:1px solid #e7e7e7; border-radius:12px; padding:12px; background:#fff; margin-bottom: 10px; margin-top: 10px;}
  label { display:block; font-size:.85rem; color:#555; margin-bottom:4px; }
  table { width:100%; border-collapse: collapse; }
  th, td { border-bottom:1px solid #eee; text-align:left; padding:8px; }
  th { background:#fafafa; position: sticky; top:0; }
  .row { display:grid; grid-template-columns: repeat(4, 1fr); gap: var(--gap); }
  #map-container { width:100%; height: 600px; display:none; border-radius:10px; margin-top: 10px;}
  
 
  
  #controls { display:flex; gap:8px; }
  .btn-primary { background:#0a7; color:#fff; border-color:#0a7; }
  .btn-primary:hover { filter: brightness(0.95); }
	/* full-page, mobile-friendly welcome overlay */
#welcome-screen {
  position: fixed;
  inset: 0;              /* top/right/bottom/left: 0 */
  z-index: 9999;
  display: none;         /* shown as flex in JS */
  background: #ffffff;
  box-sizing: border-box;
  padding: 24px 20px 32px;
  overflow-y: auto;
  overflow-x: auto;
}

.filtered-data-table {margin-bottom: 10px;
  margin-top: 10px;}
/* slightly more breathing room on tablets/desktop */
@media (min-width: 768px) {
  #welcome-screen {
    padding: 40px 60px;
  }
}

/* optional: tidy up typography inside the overlay */
#welcome-screen h1 {
  margin-top: 0;
  margin-bottom: 12px;
  font-size: clamp(26px, 4.5vw, 36px);
}

#welcome-screen p,
#welcome-screen br {
  line-height: 1.5;
}
  /* existing */
  #filtered-table-section { display:none; }
  #welcome-screen.hidden { opacity:0; pointer-events:none; }
  .info.legend {
    background: white; padding: 8px 12px; border-radius: 8px;
    box-shadow: 0 0 5px rgba(0,0,0,0.3); font-size: 14px; line-height: 18px; text-align: left;
  }
  .info.legend h4 { margin: 0 0 5px; font-size: 14px; }
  #data-table tbody tr,
	#filtered-data-table tbody tr { cursor: pointer; }
	.grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: var(--gap);
}

/* if you ever want to adjust spacing on larger screens, you can do it here */
@media (min-width: 1100px) {
  .grid {
    grid-template-columns: 1fr; /* still one column ‚Äì map and table both full width */
  }
}
	
#begin-btn {
  background: #59A6FF;       /* blue like your theme */
  color: #000000;
  border: none;
  border-radius: 12px;
  padding: 14px 30px;
  font-size: 35px;
  font-weight: 600;
  cursor: pointer;
  transition: background 0.2s ease, transform 0.1s ease;
  box-shadow: 0 3px 6px rgba(0,0,0,0.2);
}

#begin-btn:hover {
  background: #2E8BFF;
  transform: translateY(-2px);
}
.data-table {margin-bottom: 10px;
  margin-top: 10px;}
.data-table-container {margin-bottom: 10px;
  margin-top: 10px;}
#data-table-container,
#filtered-table-section {
  max-height: 560px;
  overflow: auto;
  margin-bottom: 10px;
  margin-top: 10px;
}

/* make tables horizontally scrollable on small screens */
table {
  width: 100%;
  
  border-collapse: collapse;
}

.info-btn {
  position: fixed;
  top: 10px;
  right: 10px;
  z-index: 9990;
  margin: 0;
  padding: 8px 12px;
  font-size: 16px;
  font-weight: 600;
  color: #383838;
  background: #ffffff;
  border: 1px solid #ddd;
  border-radius: 999px;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(0,0,0,0.12);
}
.info-btn:hover {
  background: #f5f5f5;
}
</style>
		
	
</head>
<body>

	<header>
	  <h2 style="margin:0">Streak Finder</h2>
	  <a class="btn" href="/">‚Üê Home</a>
	</header>

	<div class="card">
	  <h3 style="margin: 0 0 8px;">Choose the day gap (1‚Äì10)</h3>
	  <form method="POST" action="/streak" style="display:flex; gap:8px; align-items:center;">
		<input type="number" name="streak_gap" required min="1" max="10" placeholder="Enter Day Gap" style="width: 150px;">
		<button type="submit" class="btn btn-primary">Generate Football Streaks</button>
	  </form>
	</div>

	<div id="welcome-screen" hidden>
	  <h1>Consecutive Football Matches</h1>
	  <p>Ever wondered how many days of football fixtures you could attend consecutively? This app lets you achieve that!</p>
	  <p>This app looks into a database of every professional fixture planned for the 25/26 football season per country and returns consecutive fixtures</p>
	  <p></p>
	  <h2>How to Use:</h2>
	  <br>1. Firstly choose the amount of days between 2 fixtures that would define them as 'consecutive' (i.e. a streak). 
	  For example, if you choose 1, only fixtures that occur 1 day after each other will be returned as 'consecutive'. 
	  If you pick 7, fixtures that occur between 1-7 days after the previous fixture will be returned as 'consecutive'. And so on. This allows you to have breaks in between fixtures.
	  After inputting your 'day gap' and clicking Generate Football Streaks, the table of football streaks returns. 
	  Start and End date is when the streak starts and ends. Country and No. of fixtures are self explanatory</br>
	  <br>2. Click on a row. All the fixtures returned will be shown on a map and as a table underneath the map, with the date, home and away teams, and stadium.
	  Points are colour-coded based on their date - fixtures that share a date have the same colour.
	  By hovering over a row, the corresponding fixture on the map will light up. Click on a row to zoom to that fixture's location (based on the stadium).</br>
	  <br>3. Obviously on some dates there are multiple fixtures. By clicking Filter, the app filters to all the fixtures that maintain the streak but have the lowest distance to the next fixture.
	  Clicking Show Arrows after clicking Filter adds lines between these fixtures up in order of date.</br>
	  <br>4. If you want to begin again, click Show Table at the top to click on another streak, or type in another Day Gap value at the top.</br>
	  <p>
	  </p>
	  <p>Please note: fixtures for a gameweek far in advance are often all put on the same day e.g. a Sunday. It is only a few months in advance of that gameweek that the fixtures get dispersed between Fridays, Saturdays, Mondays etc. based on TV broadcasting. This is why streaks usually only occur in the next few months.</p>
	  <p>Cup games and european fixtures aren't taken into account, nor cross-border streaks. Perhaps in the future!</p>
	  <p>You can hover over any row to highlight its stadium on the map, or click a row to zoom in and open its popup.</p>
	  <p>Markers are color-coded by fixture date; see the legend in the bottom-right corner.</p>
	  <p>Click the <strong>‚Äúi‚Äù</strong> button any time to revisit this page.</p>
	  <button id="begin-btn" onclick="hideWelcome()" >BEGIN</button>
	  <h3> Current leagues included: </h3>
	  
	    <br> Premier League - England</br>
		<br> Championship - England</br>
		<br> League One - England</br>
		<br> League Two - England</br>
		<br> National League - England</br>
		<br> National League North - England</br>
		<br> National League South - England</br>
		<br> Scottish Premiership - Scotland</br>
		<br> Scottish Championship - Scotland</br>
		<br> Bundesliga - Germany</br>
		<br> Bundesliga 2 - Germany</br>
		<br> Bundesliga 3 - Germany</br>
		<br> La Liga - Spain<br/>
		<br> La Liga 2 - Spain<br/>
		<br> Primera RFEF - 1 - Spain<br/>
		<br> Primera RFEF - 2 - Spain<br/>
		<br> Ligue 1 - France<br/>
		<br> Ligue 2 - France<br/>
		<br> National (France) - France<br/>
		<br> Liga Portugal - Portugal<br/>
		<br> Liga Portugal 2 - Portugal<br/>
		<br> Serie A - Italy<br/>
		<br> Serie B - Italy<br/>
		<br> Serie C - A - Italy<br/>
		<br> Serie C - B - Italy<br/>
		<br> Serie C - C - Italy<br/>
		<br> Chance Liga - Czech Republic<br/>
		<br> Super League (Greece) - Greece<br/>
		<br> Liga 1 - Romania<br/>
		<br> Liga 2 - Romania<br/>
		<br> Super Liga - Serbia<br/>
		<br> Parva Liga - Bulgaria<br/>
		<br> Vtora Liga - Bulgaria<br/>
		<br> ChNl - Czech Republic<br/>
		<br> Eerste Divisie - Netherlands<br/>
		<br> Eredivise - Netherlands<br/>
		<br> Jupiler Pro League - Belgium<br/>
		<br> Super League (Switzerland) - Switzerland<br/>
		<br> Challenger League - Switzerland<br/>
		<br> Super Lig - Turkey<br/>
		<br> 2. Lig Red Group - Turkey<br/>
		<br> BGL Ligue - Luxembourg<br/>
		<br> Bundesliga Austria - Austria<br/>
		<br> Ekstraklasa - Poland<br/>
		<br> Division 1 (Poland) - Poland<br/>
		<br> Division 2 (Poland) - Poland<br/>
		<br> Premier Division (Ireland) - Ireland<br/>
		<br> Division 1 (Ireland) - Ireland<br/>
		<br> Superliga - Denmark<br/>
		<br> 1st Division (Denmark) - Denmark<br/>
		<br> NB I. - Hungary<br/>
		<br> NB II. - Hungary<br/>
		<br> HNL - Croatia<br/>
		<br> Prva NL - Croatia<br/>
		<br> Eliteserien - Norway<br/>
		<br> OBOS-ligaen - Norway<br/>
		<br> Allsvenskan - Sweden<br/>
		<br> Superettan - Sweden<br/>
	  
	  <p>Disclaimer: Whilst every care is taken to ensure accuracy, the information provided in this website may not be complete or fully accurate. Please double-check before relying on it.</p>
	  <p>Any issues please contact: footballmapped@proton.me</p>
	  <br></br>
	</div>
	

	
    <!--<h2>Choose the amount of days between 2 fixtures that would define them as 'consecutive': (choose between 1‚Äì10)</h2>
    <form method="POST" action="/streak">
        <input type="number" name="streak_gap" required min="1" max="10" placeholder="Enter Day Gap" style="width: 150px;">
        <button type="submit">Generate Football Streaks!</button>
		
    </form>-->
	
	<button class = "info-btn" onclick="showWelcomeAgain()">i</button>
    {% if streak_shown %}


	<div class="card">
  <div id="data-table-container">
    <table id="data-table">
      <thead>
        <tr>
          <th colspan="5"><button id="toggle-table-btn" class="btn">‚ñ≤ Hide Table</button></th>
        </tr>
        <tr>
          <th>Country</th>
          <th>Start Date of Streak</th>
          <th>End Date of Streak</th>
          <th>Number of Fixtures in Streak</th>
        </tr>
      </thead>
      <tbody>
        {% for row in df_data %}
        <tr onclick="toggleVisibility(document.querySelector('#data-table tbody'))" data-streak-id="{{ row.Streak_ID }}">
          <td>{{ row.streak_country }}</td>
          <td>{{ row.interval_start_date.strftime('%Y-%m-%d') }}</td>
          <td>{{ row.interval_end_date.strftime('%Y-%m-%d') }}</td>
          <td>{{ row.day_interval }}</td>
        </tr>
        {% endfor %}
      </tbody>
    </table>
  </div>
</div>


  
    <div>
	  <div>  Scroll below map to see the Table of Fixtures generated!</div>
    </div>
	
    <div class="map-container"></div>
	
  
  	<div id="controls" style="margin-bottom:10px; display:flex; gap:8px;">
      <button id="filter-btn" class="filter-btn">Filter for Shortest Route</button>
      <button id="toggle-lines-btn" class="btn" style="display:none">Show Arrows</button>
	  <button id="toggleLegendBtn" class="btn">Hide Legend</button>
	  </div>
  

  <div class="card" id="filtered-table-section">
    <h3 style="margin-top:0;">Fixtures</h3>
    <table id="filtered-data-table">
      <thead>
        <tr>
          <th>Date of Fixture</th>
		  
          <th>Home Team</th>
          <th>Away Team</th>
          <th>Fixture Stadium</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

    {% endif %}

    <script>
	function formatDisplayDate(date) {
		  if (!date) return '';

		  const d = new Date(date);

		  return d.toLocaleDateString('en-GB', {
			weekday: 'short',
			day: '2-digit',
			month: 'short',
			year: 'numeric',
		  });
		}

	function cleanDate(d) {
		  const arr = d.split(" ");
		  const sliced = arr.slice(1, -2); 
		  const	joined = sliced.join(" ");	  
		  return joined; // take only YYYY-MM-DD
		}
	
	function hideWelcome() {
	  const welcome = document.getElementById("welcome-screen");
	  welcome.style.display = "none";
	  welcome.setAttribute("hidden", true);
	  sessionStorage.setItem("welcomeShown", "true");
	}

	function showWelcomeAgain() {
	const welcome = document.getElementById("welcome-screen");
	welcome.style.display = "block";
	}
	
    function toggleVisibility(el) {
		
		console.log(el)
        if (el) el.style.display = (el.style.display === 'none') ? 'block' : 'none';
		console.log(el.style.display )
		document.getElementById("toggle-table-btn").textContent = "‚ñº Show Table"
    }

    function haversine(lat1, lon1, lat2, lon2) {
        const R = 6371;
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) ** 2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }

    function applyFilter(data) {
        const grouped = {};
        data.forEach(row => {
            if (!grouped[row.date]) grouped[row.date] = [];
            grouped[row.date].push(row);
        });

        const dates = Object.keys(grouped).sort();
        const result = [];

        for (let i = 0; i < dates.length; i++) {
            const curr = grouped[dates[i]];
            const next = grouped[dates[i + 1]] || [];
            let best = curr[0];
            let minDist = Infinity;
            curr.forEach(a => {
                next.forEach(b => {
                    const d = haversine(a.latitude, a.longitude, b.latitude, b.longitude);
                    if (d < minDist) {
                        best = a;
                        minDist = d;
                    }
                });
            });
            result.push(best);
        }
        return result;
    }

    let originalData = [], filteredData = [], showFiltered = false, map, markers = {}, lines;

    function renderMap(data, options = {}) {
		const container = document.querySelector("#map-container");
		if (!container) return;
		container.style.display = 'block';
		container.innerHTML = '<div id="leaflet-map" style="height:100%;width:100%"></div>';

		map = L.map('leaflet-map').setView([20, 0], 2);
		L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

		markers = {};
		const points = [];

		let colors = ["#e6194b", "#3cb44b", "#ffe119", "#4363d8", "#f58231", "#911eb4", "#46f0f0", "#f032e6", "#bcf60c", "#fabebe", "#008080", "#e6beff", "#9a6324", "#fffac8", "#800000", "#aaffc3", "#808000", "#ffd8b1", "#000075", "#808080"];
		let dateColors = {};
		let currentColorIndex = 0;

		const uniqueDates = [...new Set(data.map(r => r.date))]  // keep unique
		  .filter(Boolean)
		  .sort((a,b) => Date.parse(a) - Date.parse(b));         // sort by real date
		uniqueDates.forEach(d => {
		  dateColors[d] = colors[currentColorIndex % colors.length];
		  currentColorIndex++;
		});
		
		// ‚úÖ Add legend (date ‚Üí color)
		if (!showFiltered) {
		
			const formatDate = d =>
			new Date(d).toISOString().slice(0, 10);
			const legend = L.control({ position: "bottomright" });
			legend.onAdd = function () {
			  const div = L.DomUtil.create("div", "info legend");
			  div.innerHTML = "<h4>Fixture Dates</h4>";
			  uniqueDates.forEach(date => {
			  div.innerHTML += `
				<div>
				  <span style="display:inline-block;width:15px;height:15px;background:${dateColors[date]};margin-right:5px;"></span>
				  ${formatDate(date)}
				</div>`;
			});
			  return div;
			};
			legend.addTo(map);
			window._legendCtrl = legend;
		}
		
		// ‚úÖ Build map of unique_id ‚Üí all order numbers
		const orderMap = {};
		data
		  .slice()
		  .sort((a, b) => Date.parse(a.date) - Date.parse(b.date))
		  .forEach((row, idx) => {
			if (!orderMap[row.unique_id]) orderMap[row.unique_id] = [];
			orderMap[row.unique_id].push(idx + 1); // store 1-based index
			
		});
		 // ‚úÖ Sort by date before drawing 
		data
		  .slice()
		  .sort((a, b) => Date.parse(a.date) - Date.parse(b.date))
		  .forEach((row, index) => {
			const { latitude: lat, longitude: lon, unique_id: id } = row;
			if (lat == null || lon == null) return;

			let popupText = `${row.date_and_time}: ${row.home} vs ${row.away} @ Stadium: ${row["Stadium Name"]}`;
			if (options.withArrows && index === 0) popupText = "START: " + popupText;
			else if (options.withArrows && index === data.length - 1) popupText = "END: " + popupText;

			const marker = L.circleMarker([lat, lon], {
				radius: 6,
				color: 'black',
				fillColor: dateColors[row.date],
				fillOpacity: 0.9
			}).addTo(map).bindPopup(popupText);
					
		if (showFiltered) {

			const orderLabels = orderMap[id].join(","); // e.g. "2,6"

			// üëâ random angle, fixed radius around the point
			const radiusDeg = 0.01; // distance in degrees (~small visual offset) ‚Äì tweak this value
			const angle = Math.random() * 2 * Math.PI;

			// correct longitude offset for current latitude
			const latRad = lat * Math.PI / 180;
			const offsetLat = radiusDeg * Math.sin(angle);
			const offsetLon = (radiusDeg * Math.cos(angle)) / Math.cos(latRad);

			const labelLat = lat + offsetLat;
			const labelLon = lon + offsetLon;

			L.marker([labelLat, labelLon], {
				icon: L.divIcon({
					className: "order-label",
					html: `<b style="color:white;font-size:18.5px;
									text-shadow:-1px -1px 2px black,1px -1px 2px black,
												-1px 1px 2px black,1px 1px 2px black;">
							  ${orderLabels}
						   </b>`,
					iconSize: [30, 20],
					iconAnchor: [15, -10]
				})
			}).addTo(map);
		}

			markers[id] = marker;
			points.push([lat, lon]);
		});

		// ‚úÖ Draw arrows in date order
		if (options.withArrows && points.length > 1) {
			lines = L.polyline(points, { color: 'red', weight: 4 }).addTo(map);
		}

		if (points.length) map.fitBounds(points);
	}	
		//welcome screen
	document.addEventListener("DOMContentLoaded", () => {
	  const welcome = document.getElementById("welcome-screen");
	  const alreadyShown = sessionStorage.getItem("welcomeShown");
	  console.log("SessionStorage says welcomeShown:", alreadyShown);
	  
	  if (alreadyShown === "true") {
		welcome.setAttribute("hidden", true);
		welcome.style.display = "none";
	  } else {
		welcome.removeAttribute("hidden");
		welcome.style.display = "block"; 
	  }
	});


	
    document.addEventListener("DOMContentLoaded", () => {
        document.querySelectorAll("#data-table tbody tr").forEach(tr => {
            tr.addEventListener("click", () => {
                const id = tr.dataset.streakId;
                fetch(`/get_streak/${id}`).then(res => res.json()).then(data => {
                    originalData = data.df_data;

                    filteredData = data.filtered_data; //this actually worked holy moly

                    const tbody = document.querySelector("#filtered-data-table tbody");
                    tbody.innerHTML = "";
                    originalData.forEach(row => {
                        const tr = document.createElement("tr");
                        tr.dataset.id = row.unique_id;
                        tr.dataset.lat = row.latitude;
                        tr.dataset.lon = row.longitude;
                        tr.innerHTML = `<td>${row.date_and_time}</td> <td>${row.home}</td><td>${row.away}</td><td>${row["Stadium Name"]}</td>`;
                        tbody.appendChild(tr);
						
						
										// add hover + click now (markers will exist after renderMap runs)
						tr.addEventListener("mouseover", () => markers[row.unique_id]?.setStyle({ color: 'yellow', radius: 12 }));
						tr.addEventListener("mouseout", () => markers[row.unique_id]?.setStyle({ color: 'black', radius: 6 }));
						tr.addEventListener("click", () => {
							const marker = markers[row.unique_id];
							if (marker) {
								marker.openPopup();
								map.setView(marker.getLatLng(), 10, { animate: true });
							}
						});
						
						
                    });

                    renderMap(originalData);
                    document.getElementById("filtered-table-section").style.display = 'block';
					
                });
            });
        });

        document.getElementById("filter-btn").addEventListener("click", () => {
			showFiltered = !showFiltered;
			const arrowBtn = document.getElementById("toggle-lines-btn");

			// ‚úÖ Always hide arrows + reset button text
			arrowBtn.style.display = showFiltered ? "inline-block" : "none";
			arrowBtn.textContent = "Show Arrows";

			// ‚úÖ Pick the correct dataset
			const data = showFiltered ? filteredData : originalData;

			// ‚úÖ Render map without arrows
			renderMap(data);

			// ‚úÖ Rebuild the table (sorted by date)
			const tbody = document.querySelector("#filtered-data-table tbody");
			tbody.innerHTML = "";
			data
			  .slice()
			  .sort((a, b) => Date.parse(a.date) - Date.parse(b.date))
			  .forEach(row => {
				const tr = document.createElement("tr");
				tr.dataset.id = row.unique_id;
				tr.dataset.lat = row.latitude;
				tr.dataset.lon = row.longitude;
				tr.innerHTML = `
				  <td>${(row.date).slice(0,  -12)}</td>
				  <td>${row.time}</td>
				  <td>${row.home}</td>
				  <td>${row.away}</td>
				  <td>${row["Stadium Name"]}</td>
				`;
				tbody.appendChild(tr);

				// ‚úÖ Attach hover/click
				tr.addEventListener("mouseover", () => markers[row.unique_id]?.setStyle({ color: 'yellow', radius: 12 }));
				tr.addEventListener("mouseout", () => markers[row.unique_id]?.setStyle({ color: 'black', radius: 6 }));
				tr.addEventListener("click", () => {
					const marker = markers[row.unique_id];
					if (marker) {
						marker.openPopup();
						map.setView(marker.getLatLng(), 10, { animate: true });
					}
				});
			  });

			// ‚úÖ Update filter button text
			document.getElementById("filter-btn").textContent = showFiltered ? "Show Original" : "Filter for Shortest Route";
		});

		document.getElementById("toggle-lines-btn").addEventListener("click", () => {
			const btn = document.getElementById("toggle-lines-btn");
			const data = showFiltered ? filteredData : originalData;

			if (btn.textContent.includes("Show")) {
				btn.textContent = "Hide Arrows";
				renderMap(data, { withArrows: true }); // ‚Üê pass flag to draw arrows
			} else {
				btn.textContent = "Show Arrows";
				renderMap(data, { withArrows: false }); // ‚Üê redraw without arrows
			}
		});
    });
	
	let legendVisible = true;
	const toggleLegendBtn = document.getElementById("toggleLegendBtn");
	if (toggleLegendBtn) {
	  toggleLegendBtn.addEventListener("click", () => {
		if (!window._legendCtrl) return;
		if (legendVisible) {
		  map.removeControl(window._legendCtrl);
		  legendVisible = false;
		  toggleLegendBtn.textContent = "Show Legend";
		} else {
		  window._legendCtrl.addTo(map);
		  legendVisible = true;
		  toggleLegendBtn.textContent = "Hide Legend";
		}
	  });
	}
	
	//show/hide Table
	const toggleTableBtn = document.getElementById("toggle-table-btn");
    const tableBody = document.querySelector("#data-table tbody"); //so this is the name of our table

    // Toggle table visibility when the button is clicked
    toggleTableBtn.addEventListener("click", function () {
        if (tableBody.style.display === "none") {
            tableBody.style.display = "table-row-group"; // Show table
            toggleTableBtn.textContent = "‚ñ≤ Hide Table";
        } else {
            tableBody.style.display = "none"; // Hide table
            toggleTableBtn.textContent = "‚ñº Show Table";
        }
    });
	

    </script>
</body>
</html>
